<%

const { messages, locale, getVariant, patternToHtml } = locals;
languageStrings = [];
plurals = [];

// list of characters that need to be escaped when converting from ini to string format
// '<' // (less than), escaped as &lt;
// '>' // (greater than), escaped as &gt;
// '&' // (ampersand), escaped as &amp;
// "'" // (apostraphe), escaped as &apos;
// '"' // (quote mark), escaped as &quot;


function variantToValue(variant) {
	let value = '';
	for (const patternPart of variant.pattern) {
		if (patternPart.type === 'Text') {
			value += patternPart.value;
		} else if (patternPart.type === 'VariableReference') {
			const variableName = patternPart.name;
			// TODO #19 check the type and use different placeholder
			// TODO #20 support indexed placeholders instead of just %@ use %1$@ and derive the index if needed
			value += '%@';
		}
	}
	return value;
}

function mask(value, quoteWrapped) {
	let stringValue = value;
	
	// TODO #8 replace all placeholders - stringValue = stringValue.replace(/%@/g, "%s"); ...
	stringValue = stringValue.replace(/&/g, "&amp;");
	if (quoteWrapped) {
		stringValue = stringValue.replace(/"/g, '\\"');
	} else {
		stringValue = stringValue.replace(/'/g, "\\'");
	}
	return stringValue
}

for (const message of messages) { 
	
	if (message.selectors.length === 0) {
		// ==========================================
		// Singular String found (e.g. Language = de)
		// ==========================================

		// get only the data for the language we need
		const variant = getVariant(message, { where: { languageTag: locale, match: [] }})

		if (variant === undefined) {
			continue;
		}
		
		let stringValue = mask(variantToValue(variant), true);
		const messageName = message.id;
		

		// creates an item with only the essential data to be serialized/printed
		languageElement = {};
		languageElement.messageName = messageName;
		languageElement.value =  stringValue;
		// languageElement.comment = translations.comment;
		languageStrings.push(languageElement);
	} else {
		// TODO #18 implement this to support strings with plurals and gender 
		/*
		// ==========================================
		// Plurals! (NO Singular String = assuming plurals)
		// ==========================================
		let pluralTranslations = {
			messageName: messageName,
			translations: {

			}
		};
		console.log(key.translations)
		console.log(language)
		console.log(key.translations[language]);
		for (let plural of Object.keys(key.translations[language])) {
			console.log(plural)
			pluralTranslations.translations[plural] = mask(key.translations[language][plural].text, true);
		}
		plurals.push(pluralTranslations)
		*/
		throw new Error('Plurals and Gender are not yet supportet for export - ignoring Message '+ message.id +'')
	}

}

// sort the lists by key
// languageStrings.sort((a, b) => a.key.localeCompare(b.key));
//plurals.sort((a, b) => a.key.localeCompare(b.key));

//////////////////////////////////////
///				  BEGIN TEMPLATE 				 ///
//////////////////////////////////////
-%>
<?xml version="1.0" encoding="utf-8"?>
<!--
	Android Strings File
	Generated 
	Language: <%-locale %>
	AUTOGENERATED: DO NOT EDIT!
-->
 <resources>

	 <!-- Singulars -->

	 <%_ for (let i = 0; i < languageStrings.length; i++) { _%>
		 <%_ if (languageStrings[i].comment != null) { _%>
     <!--Comment: <%-languageStrings[i].comment%> -->
	   <%_ } _%>
	 <string name="<%-languageStrings[i].messageName%>">"<%-languageStrings[i].value%>"</string>
	 <%_ } _%>


	<!-- PLURALS -->

	<%_ for (let i = 0; i < plurals.length; i++) { _%>

	<plurals name="<%-plurals[i].key%>">
		<%_ if (plurals[i].comment != null) { _%>
		<!--Comment: <%-plurals[i].comment%> -->
		<%_ } _%>
		<%_ for (const [pluralKey, translation] of Object.entries(plurals[i].translations)) { _%>
		<item quantity="<%-pluralKey%>">"<%-translation%>"</item>
		<%_ } _%>
	</plurals>
	<%_ } _%>

</resources>
